[{"content":"介绍 瘦身的目的就是减少整个仓库的文件体积，为此，我们需要分析当前各个 BSP 中占用空间较大的部分\n在此之前，已有开发者发布了一篇详细的瘦身指南，具体在下方链接可以查看: RT-Thread-rt-thread主仓 BSP瘦身指南RT-Thread问答社区 - RT-Thread\n这里以NXP的为例子，我们可以用SpaceSniffer查看该目录的文件占用\n从图中可以看出，仓库中占用空间较多的主要是一些 library 及与 SDK 相关的内容。这些库本身并不直接依赖 RT-Thread 内核，而是通过适配层与系统进行对接。因此，我们可以将这些库拆分出来，分别制作成独立的软件包进行管理和维护，以减少 BSP 体积。\n开始操作 为了方便演示瘦身的具体操作步骤，我们以图中右下角的MCX为例进行说明，该BSP适配的比较标准，适合作为示例，能够更直观地展示瘦身的原理和过程\n瘦身主要分为三个步骤，首先是创建对应的SDK仓库，然后是修改Package软件包索引仓库，最后是修改RT-Thread主仓仓库中的BSP\n瘦身本质的核心就是将占用比较多的文件或者库分成单独的仓库\n这一套流程不仅适用于 BSP 的瘦身，同样适用于向 RT-Thread 生态中添加新的软件包\n本文中提交PR的步骤可以参考 RT-Thread-【RT-Thread】记录一次对主仓的bsp进行修复并提交pr的总结RT-Thread问答社区 - RT-Thread\n创建SDK（软件包）仓库 在创建仓库前，首先需要分析当前目录结构，明确哪些内容需要拆分成独立仓库\n来到nxp/mcxa目录下，可以看到该目录下包含两个 BSP，以及一个位于 BSP 外部的 Library 文件夹\n其中Library 中包含一个通用的 CMSIS 文件夹，这是两个 BSP 在编译过程中都会引用的公共部分，需要作为通用 SDK 提取出来\ndrivers 是用于适配 RT-Thread 的驱动代码，属于 BSP 的一部分，不需要拆分为软件包\n此外还有两个 BSP 专属的库文件夹，这两部分可以合并为一个软件包，并通过 SConstruct 文件中的配置来控制编译时启用哪个文件夹，以适配不同的 BSP\n（注：除了library之类的代码，如果还有对应bsp需要的工具或文件的话，比如IMX6ULL-Smart这个bsp目录下还有个emmc文件夹，那么可以把其一起放到对应的软件包文件夹下 ）\n在明确library库中的内容后，我这里打算分别创建出nxp-mcx-cmsis和nxp-mcx-series两个仓库\n制作软件包并测试 这里可以在package下创建文件夹模拟测试下是否能通过编译：\n以 frdm-mcxa156 为例,来到其目录下，打开env，输入pkgs \u0026ndash;update让他创建出Packages文件夹，接下来在这个文件夹下分别创建出nxp-mcx-cmsis和nxp-mcx-series的文件夹\n将原 Library 文件夹中的 cmsis 目录内容放到nxp-mcx-cmsis中(可以理解为将 cmsis 改名为 nxp-mcx-cmsis)，另外两个 BSP 专属的库文件夹，则统一放入 nxp-mcx-series 软件包中，后续可通过 SConstruct 控制编译时选择具体子目录，以适配不同 BSP。最后的结果如下图所示，然后原本的cmsis和库文件就可以删除了。\nscons是如何编译需要的.c文件的 在默认情况下，SCons 的编译流程主要依赖于 SConscript 文件中指定的路径来递归查找 BSP 目录下所有需要编译的 .c 文件。\n如果源码目录结构中存在多层嵌套，那么每一层目录下都需要有一个 SConscript 文件。因为 SCons 会从上层向下逐级查找 SConscript，并通过它们逐层递归构建编译路径。\n一旦某一层目录中缺失了 SConscript，则该路径下更深层的 .c 文件将无法被发现和编译，从而导致编译不完整或链接错误。\n但是从上图中可以发现nxp-mcx-series下是少了SConscript的，这会导致里面的文件编译不进去，于是我们可以手动给它加上\n其中的内容可以参考下图，每个专属的库都对应的一个SOC宏定义，当这个判断到这个宏定义后就会把对应的库中的SConscript中指定的C文件加入到构建中\n然后检查下对应的库中的SConscript，我这里是MCXA156,可以打开检查下MCXA156\\SConscript\n发现CMSIS也包含在里面，那么把这个CMSIS改成nxp-mcx-cmsis是不是nxp-mcx-cmsis就不用创建SConscript了，实际上这样会报错，在拉取软件包的时候由于用的是最新的代码，那么nxp-mcx-cmsis的命名就会变成nxp-mcx-cmsis_latest,这时就会报错\n为了方便可能出现的不同版本，同时也让软件包更整洁一点，还是要在nxp-mcx-cmsis创建一个SConscript,内容为下图所示\n那么原来的nxp-mcx-series中的SConscript则删掉 cwd + \u0026lsquo;/../CMSIS/Core/Include\u0026rsquo;, 即可\n这样nxp-mcx-cmsis和nxp-mcx-series两个软件包就做好了\n接下来是把原本bsp查找library路径修改一下就好了\n前面提到，SCons 的构建过程主要依赖于各级目录下的 SConscript 文件来组织和管理需要编译的 .c 文件。那么，SCons 最开始是从哪里开始执行的呢？\n实际上，SCons 会从BSP根目录下的 SConstruct 文件开始执行，这是整个构建系统的入口文件。SConstruct 正常情况下只会从bsp根目录下开始搜索，进而递归来添加该 BSP 所需编译的所有源文件。\n如果需要搜索bsp目录外的文件夹，则需要指定对应的目录，比如说上图，首先objs添加了RTT内核，其次是drivers驱动，最后是library里的库文件\n所以为了适配软件包，则需要把这一行添加库文件夹的代码去掉\n1 objs.extend(SConscript(os.path.join(libraries_path_prefix, rtconfig.BSP_LIBRARY_TYPE, \u0026#39;SConscript\u0026#39;))) 这时候又由于默认会自动搜索BSP根目录下所有文件夹包括packages里的SConscript，所以软件包方面不用额外添加路径\n这时候就可以尝试编译一下\n结果可以看到库文件的路径来自于Packages，编译也是通过的\n提交到github仓库 首先，需要在 GitHub 上创建两个仓库，并分别命名为 nxp-mcx-cmsis 和 nxp-mcx-series，同时记录下这两个仓库对应的 Git 拉取地址。\n接着，在本地打开 packages 文件夹内对应这两个文件夹路径的 Git Bash 窗口。\n最后，按照以下命令将 SDK 提交至远端仓库中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #初始化仓库 git init #设置远端仓库 git remote add 拉取对应仓库用的git地址 #拉取代码 git pull origin master #将修改的文件添加到暂存 git add . #将暂存区的文件提交成commit git commit \u0026#34;First Commit\u0026#34; #推送到github服务器上 git push origin master 修改Package软件包索引仓库 接下来是修改软件包的索引仓库，效果就是Menuconfig打开相应的宏定义即可自动下载对应的软件包\n来到软件包仓库GitHub - RT-Thread/packages: packages index repository for rt-thread.\n首先需要将仓库Fork成自己的package仓库\n然后来到自己的package仓库，找到clone地址\n在本地找一个地方拉取一下\n这里推荐一个package拉取的地方\n正常来说，env工具本身也会拉取package，于是我们可以来到env的安装目录下，找到对应的package目录，删除后重新在该位置拉取一个package，这样在调试的时候就能随时使用到最新代码\n拉取到本地后，用vscode打开packages，然后来到peripherals\\hal-sdk目录下\n找到对应bsp的文件夹，没有的话可以根据其他文件夹的命名规范来新建\n然后在bsp下创建Kconfig和package.json，如下图所示\n其中的内容可以参考其他sdk的配置来修改\n注意，这里面的Kconfig跟上面提到的SConscript有点类似，也是为了能让env找到sdk的配置，所以每个文件夹下都有\n将对应的配置路径填入到上层文件夹中的Kconfig即可，具体可以参考其他SDK\n全部写好后就可以提交pr了，打开git bash\n1 2 3 4 5 6 7 8 9 10 11 #将文件添加到暂存区 git add . #创建分支 git checkout -b nxp_sdk #提交暂存区文件到commit git commit -m \u0026#34;这里填写commmit描述\u0026#34; #推送远端仓库 git push origin nxp_sdk 推送到github上自己的仓库后，就可以在网页端操作提交pr了\n关于软件包相关的部分详细可以参考其他的文章和视频比如\n\\[RTT\\]\\[ENV\\]\\[PACKAGE\\]如何制作软件包_rtt env packages-CSDN博客\nEnv上手指南_哔哩哔哩_bilibili\n修改RT-Thread主仓仓库 首先如果需要在主仓上提交代码，我们需要把仓库fork一下，然后拉取自己的RT-Thread仓库到本地即可,其步骤跟修改索引仓库一样\n在第一步的测试中，BSP 已经能够正常编译。接下来，如果要实现对应 SDK 的自动下载功能，则需要借助软件包索引仓库中的宏定义来完成。\n当使用menuconfig保存退出后，env会自动将Kconfig下开启的宏定义放到rtconfig.h中，这时如果使用了pkgs \u0026ndash;update并检测到PKG_开头的宏定义就会根据索引仓库的配置下载对应的软件包\n于是按照这个思路，首先找到这个系列的bsp都会开启的选项，然后在这个选项下面加入刚才索引仓库配置的宏定义就可以了\n如下图的例子中，我找到了一个SOC_MCX的一个config，当menuconfig保存退出后，就会自动搜索打开select中的选项，这里把sdk的config开关填进去即可\n到了这里，bsp的基础瘦身就完成了,接下来是添加一些提示之类的，告诉其他开发者在编译前需要输入pkgs \u0026ndash;update下载sdk\n打开当前bsp的SConscript,加入下图中的代码，作用就是检测packages目录下有没有对应的sdk文件夹,没有的话就会报错并提示\n注意：软件包再拉下来的时候会自动在文件夹名后加上-latest，修改的时候不要漏了\n最后可以测试一下，把原来的文件夹删除后即可输入pkgs \u0026ndash;update下载sdk，编译通过后即可开始提交pr\n可以参考下面的链接: RT-Thread-【RT-Thread】记录一次对主仓的bsp进行修复并提交pr的总结RT-Thread问答社区 - RT-Thread\n总结 这里总结下步骤 首先，需要创建对应的SDK仓库； 这个仓库会在pkgs \u0026ndash;update时下载到packages文件夹里，然后scons编译工具会根据其中的SConscript来决定编译哪个c文件\n接着，修改Package软件包索引仓库； 这个仓库主要是用来链接软件包的仓库，并将该软件包跟宏定义绑定，这样env才可以找到该软件包的仓库并下载下来\n最后，更新RT-Thread主仓仓库中的BSP； 为了使 BSP 在执行 pkgs \u0026ndash;update 时能够正确工作，需要确保对应软件包的宏定义处于开启状态。因此，必须在 Kconfig 文件中选择一个默认开启的选项，并将该宏定义包含其中。这样一来，在通过 menuconfig 配置后，就能启用该宏定义。 （注：menuconfig 中的选项均来源于 Kconfig 文件。）\n","date":"2025-05-22T01:59:41+08:00","permalink":"https://hydevcode.github.io/p/rt-thread%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AF%B9%E5%85%B6%E4%BB%96bsp%E8%BF%9B%E8%A1%8C%E7%98%A6%E8%BA%AB%E5%B9%B6%E6%B7%BB%E5%8A%A0%E8%BD%AF%E4%BB%B6%E5%8C%85/","title":"RT-Thread中如何对其他BSP进行瘦身并添加软件包"},{"content":"前言 当我们往RT-Thread仓库提交PR代码也就是对仓库做修改的时候，来到提交的PR底下可以看到一些Build Check，如下图所示\n这些Check的作用就是编译与其对应的BSP，就好像本地使用scons -j4编译一样\n当所有测试通过了之后就代表在该PR中修改的代码可以正常编译所在的BSP\n如果有报错也就是编译不通过的话，那么就可以很方便的定位问题来源\n怎么添加BSP的自动编译测试 问题来了，那么当添加了一个新的BSP的时候该如何让它也能支持自动编译呢\n来到.github目录下可以找到一个叫ALL_BSP_COMPILE.json的文件 这里面就包含了所有需要自动编译测试的bsp\n当我们添加了一个新的BSP时，只需要按照原有的格式，将BSP的路径添加到列表中即可\n但是需要注意几点\n首先，每个BSP都应该被放入正确的组中。举个例子，如果添加的是STM32F7系列的BSP，那么就应该将其路径放入相应的组。如下图的的RTT_BSP就类似于组名\n如果在现有的组中找不到合适的位置，那么就可以按照已有的格式新增一个组\n添加完成后可以验证一下看是否成功添加\n来到PR页面的最下方，找到刚添加的bsp对应的组名，点击链接\n这里以星火一号RT-SPARK为例子\n展开BSP Scons Compile即可看到bsp路径\n如何在自己仓库上进行自动编译测试 (在自己仓库上编译需要修改一下仓库文件，删除.github/workflows/bsp_buildings.yml中的if: github.repository_owner == \u0026lsquo;RT-Thread\u0026rsquo; 即可在自己的仓库编译测试，顺便可以把schedule:- cron: '0 16 * * *' 也删了，这个是定时运行，时间长了仓库会有一堆编译记录，这个操作仅用于自己测试，最后提交PR代码的时候记得还原)\n首先确保RT-Thread仓库已经fork到自己仓库了(也就是类似于复制一份仓库到自己仓库中) 然后来到自己的RT-Thread仓库\n点击Actions,然后在左边的列表找到Build Check，在右边可以看到一个Run workflow ，按下那个绿色按钮就会开始自动对所有bsp进行编译了\n此时刷新一下网页会发现多出来一个棕色的Build Check，这时说明正在进行测试，只需要等待测试结束即可\n另外CI还有其他好玩的用法，结合起来做项目十分方便\nRT-Thread-还在担心bsp不好维护吗？快使用yml管理主线bspRT-Thread问答社区 - RT-Thread\nRT-Thread-RT-Thread CI编译产物artifacts自动上传功能介绍RT-Thread问答社区 - RT-Thread\nRT-Thread-【ci】【github】【bsp】RT-THREAD所有bsp scons编译情况检查RT-Thread问答社区 - RT-Thread\nRT-Thread-\\[github\\]\\[action\\] RTT黑科技: 添加手动打包和编译特定bsp功能RT-Thread问答社区 - RT-Thread\n","date":"2025-04-08T19:20:00+08:00","permalink":"https://hydevcode.github.io/p/rt-thread%E4%BB%93%E5%BA%93%E7%9A%84ci%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E6%B5%8B%E8%AF%95/","title":"RT-Thread仓库的CI自动编译测试"},{"content":" 😀 由于需要在PR上用bot发送评论，所以可能需要用到pull_request_target,但是官方文档提示该触发条件有安全风险,于是研究下并做个笔记 触发工作流的事件 - GitHub 文档\n在 GitHub Actions 中，pull_request 和 pull_request_target 是两种处理 Pull Request (PR) 的触发器,以下是我的理解介绍以及对比：\n📝 什么是pull_request? 当 PR 被创建、更新（新提交）或 重新打开 时触发工作流 专为 处理 PR 贡献者的代码 设计 特性 说明 代码环境 使用 PR 分支的代码（即贡献者的代码） 权限 GITHUB_TOKEN 默认只有 读权限 Secrets 无法访问仓库的加密 secrets 目标分支 无法直接访问目标分支（如 main）的最新代码 使用示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 on: #触发条件设置↓ pull_request: branches: [ main ] permissions: contents: read # 显式声明最低权限 jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 # 自动签出 PR 代码 📝 什么是pull_request_target? 专门用于 维护者审核 PR 时 需要 高权限操作 的场景 特性 说明 代码环境 默认使用 目标分支的代码（如 main 分支），而非 PR 代码 权限 GITHUB_TOKEN 默认拥有 写权限（可修改仓库） Secrets 可以访问仓库的加密 secrets 目标分支 直接基于目标分支的最新代码运行 可能的安全风险 来自官方文档https://docs.github.com/zh/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows#pull_request_target\n对于由 pull_request_target 事件触发的工作流，将授予 GITHUB_TOKEN 读/写存储库权限，除非指定了 permissions密钥并且工作流可以访问机密，即使从分支触发也是如此。 虽然工作流程在拉取请求的基础上下文中运行，但你应该确保不在此事件中检出、生成或运行来自拉取请求的不受信任代码。 此外，任何缓存都与基本分支共享相同的作用域。 为帮助防止缓存中毒，如果缓存内容可能已更改，则不应保存缓存。 有关详细信息，请参阅 GitHub Security Lab 网站上的“保护 GitHub Actions 和工作流安全：阻止 pwn 请求”。\n比如： 由于 pull_request_target 默认使用的是 main 分支的代码，因此无法测试 PR 中修改的内容。为了解决这个问题，可以指定使用 PR 分支的代码，但这又会引发新的问题。\n1 2 3 4 steps: - uses: actions/checkout@v4 with: ref: ${{ github.event.pull_request.head.sha }} # 显式签出 PR 代码 当前情况： • 工作流运行在高权限环境中（可访问敏感信息） • 但执行的是来自不可信 PR 的代码 • 触发的工作流仅在提交者的分叉仓库中运行 • 攻击者可能在 PR 代码中插入恶意 CI 脚本\n安全风险主要源自于 pull_request_target 下的工作流，因为该工作流具有读取 secrets 和写入 GITHUB_TOKEN 的权限。因此，在编写 YAML 文件时需要特别注意。\n在网上搜索到的一些解决办法可以有效提高 GitHub Actions 的安全性，具体措施如下：\n禁用凭证持久化 (persist-credentials: false)：当使用 actions/checkout 动作时，默认情况下，GitHub 会将 GITHUB_TOKEN 写入本地的 Git 配置文件（存储在 .git/config 中）。这意味着后续的所有 Git 操作（如 push 或 pull）都会自动使用这个令牌进行身份验证。然而，为了增强安全性并避免潜在的风险，可以通过设置 persist-credentials: false 来主动删除这些凭证信息。这一步骤确保了即使代码库中存在敏感操作，也不会因为误用或泄露令牌而引发安全问题。 最小化权限配置：在 GitHub Actions 的工作流文件中，可以使用 permissions 块来显式声明每个步骤所需的权限。通过这种方式，可以确保每个作业只拥有完成任务所必需的最低权限。例如，如果某个作业只需要读取仓库内容，则不应授予其写入权限。这种做法不仅减少了不必要的权限暴露，还降低了因权限滥用而导致的安全风险。 隔离敏感操作：为了进一步提升安全性，建议将签出代码的操作与任何涉及写入的操作分离到不同的作业（job）中。这样做可以有效防止在同一环境中同时执行读取和写入操作，从而减少意外修改或恶意攻击的可能性。通过将不同类型的任务分隔开，可以更好地控制和监控每个作业的行为，确保整个工作流的安全性和稳定性。 通过以上这些方法，不仅可以提高 GitHub Actions 的安全性，还能帮助开发者更清晰地管理和控制各个作业之间的权限和操作，从而构建更加健壮和可靠的自动化流程。\nWorkFlow_Run 在官方的一篇文章中，官方提供了一种解决办法,而且给出的示例也刚好符合实现在PR发送评论的需求\nhttps://securitylab.github.com/resources/github-actions-preventing-pwn-requests/\n与pull_request_target一起，引入了一个新的触发器workflow_run，以支持需要构建不受信任的代码并且还需要写入权限来更新 PR（例如代码覆盖率结果或其他测试结果）的方案。要以安全的方式执行此作，必须通过 pull_request 触发器处理不受信任的代码，以便将其隔离在非特权环境中。然后，处理 PR 的工作流应将任何结果（如代码覆盖率或失败/通过的测试）存储在构件中并退出。然后，以下工作流程从 workflow_run 开始，在该位置被授予对目标存储库的写入权限和对存储库密钥的访问权限，以便它可以下载项目并对存储库进行任何必要的修改，或与需要存储库密钥（例如 API 令牌）的第三方服务交互。\n这里用的是官方的一个示例，其中分别有两个工作流，关键注意这两个工作流的触发事件一个是pull_request一个是workflow_run\n当贡献者提交PR时，会触发相应的CI流程。由于Receive PR工作流使用的是pull_request事件，默认情况下无法访问机密信息且不具备写入权限。该工作流运行完毕后，会将处理结果及PR编号存储在构件中。随后，workflow_run检测到Receive PR工作流已结束，于是触发该工作流并开始执行其定义的任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 name: Receive PR # read-only repo token # no access to secrets on: pull_request: jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 # imitation of a build process - name: Build run: /bin/bash ./build.sh - name: Save PR number run: | mkdir -p ./pr echo ${{ github.event.number }} \u0026gt; ./pr/NR - uses: actions/upload-artifact@v2 with: name: pr path: pr/ Comment on the pull request工作流将Receive PR的构件下载回来，然后根据PR号对相应的PR发送评论\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 name: Comment on the pull request # read-write repo token # access to secrets on: workflow_run: workflows: [\u0026#34;Receive PR\u0026#34;] types: - completed jobs: upload: runs-on: ubuntu-latest if: \u0026gt; github.event.workflow_run.event == \u0026#39;pull_request\u0026#39; \u0026amp;\u0026amp; github.event.workflow_run.conclusion == \u0026#39;success\u0026#39; steps: - name: \u0026#39;Download artifact\u0026#39; uses: actions/github-script@v3.1.0 with: script: | var artifacts = await github.actions.listWorkflowRunArtifacts({ owner: context.repo.owner, repo: context.repo.repo, run_id: ${{github.event.workflow_run.id }}, }); var matchArtifact = artifacts.data.artifacts.filter((artifact) =\u0026gt; { return artifact.name == \u0026#34;pr\u0026#34; })[0]; var download = await github.actions.downloadArtifact({ owner: context.repo.owner, repo: context.repo.repo, artifact_id: matchArtifact.id, archive_format: \u0026#39;zip\u0026#39;, }); var fs = require(\u0026#39;fs\u0026#39;); fs.writeFileSync(\u0026#39;${{github.workspace}}/pr.zip\u0026#39;, Buffer.from(download.data)); - run: unzip pr.zip - name: \u0026#39;Comment on PR\u0026#39; uses: actions/github-script@v3 with: github-token: ${{ secrets.GITHUB_TOKEN }} script: | var fs = require(\u0026#39;fs\u0026#39;); var issue_number = Number(fs.readFileSync(\u0026#39;./NR\u0026#39;)); await github.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: issue_number, body: \u0026#39;Everything is OK. Thank you for the PR!\u0026#39; }); 💡 有关题目或文章的问题，欢迎您在底部评论区留言，一起交流~\n","date":"2025-03-15T19:20:00+08:00","permalink":"https://hydevcode.github.io/p/github-pull_request_target%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Github Pull_request_target学习笔记"},{"content":"这是第一篇文章，讲一讲该博客的情况\n这个博客主要用于记录随笔笔记之类的，而整理好的文章会发到notion那边去\n","date":"2025-03-14T21:13:57+08:00","permalink":"https://hydevcode.github.io/p/my-first-post/","title":"My First Post"}]